import https from 'https';
import crypto from 'crypto';
import express from 'express';
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import WebSocket from 'ws';

// Import API_KEY v√† SECRET_KEY t·ª´ config.js
import { API_KEY, SECRET_KEY } from './config.js';

// L·∫•y __filename v√† __dirname trong ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// --- BASE URL C·ª¶A BINANCE FUTURES API ---
const BASE_HOST = 'fapi.binance.com';
const WS_BASE_URL = 'wss://fstream.binance.com';
const WS_USER_DATA_ENDPOINT = '/ws';

let serverTimeOffset = 0; // Offset th·ªùi gian ƒë·ªÉ ƒë·ªìng b·ªô v·ªõi server Binance
let exchangeInfoCache = null; // Bi·∫øn cache cho exchangeInfo ƒë·ªÉ tr√°nh g·ªçi API l·∫∑p l·∫°i
let isClosingPosition = false; // C·ªù ƒë·ªÉ tr√°nh g·ª≠i nhi·ªÅu l·ªánh ƒë√≥ng c√πng l√∫c
let botRunning = false; // Bi·∫øn c·ªù ƒëi·ªÅu khi·ªÉn tr·∫°ng th√°i bot (ch·∫°y/d·ª´ng)
let botStartTime = null; // Th·ªùi ƒëi·ªÉm bot ƒë∆∞·ª£c kh·ªüi ƒë·ªông

// --- BI·∫æN TR·∫†NG TH√ÅI V·ªä TH·∫æ M·ªöI (HEDGING) ---
let currentLongPosition = null;
let currentShortPosition = null;

// Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ setInterval cho vi·ªác ki·ªÉm tra v·ªã th·∫ø ƒëang m·ªü
let positionCheckInterval = null;
let nextScheduledCycleTimeout = null; // Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ setTimeout cho l·∫ßn ch·∫°y ti·∫øp theo c·ªßa chu k·ª≥ ch√≠nh (runTradingLogic)
let retryBotTimeout = null; // Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ setTimeout cho vi·ªác t·ª± ƒë·ªông kh·ªüi ƒë·ªông l·∫°i bot sau l·ªói nghi√™m tr·ªçng

// === START - BI·∫æN QU·∫¢N L√ù L·ªñI V√Ä T·∫¶N SU·∫§T LOG ===
let consecutiveApiErrors = 0;
const MAX_CONSECUTIVE_API_ERRORS = 3;
const ERROR_RETRY_DELAY_MS = 10000;

const logCounts = {};
const LOG_COOLDOWN_MS = 2000;

class CriticalApiError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CriticalApiError';
    }
}
// === END - BI·∫æN QU·∫¢N L√ù L·ªñI V√Ä T·∫¶N SU·∫§T LOG ===

// --- C·∫§U H√åNH BOT C√ÅC THAM S·ªê GIAO DUC (GI√Å TR·ªä M·∫∂C ƒê·ªäNH) ---
let INITIAL_INVESTMENT_AMOUNT = 1; // M·∫∑c ƒë·ªãnh 1 USDT
let TARGET_COIN_SYMBOL = 'ETHUSDT'; // M·∫∑c ƒë·ªãnh ETHUSDT

// Bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ t·ªïng l·ªùi/l·ªó
let totalProfit = 0;
let totalLoss = 0;
let netPNL = 0;

// --- BI·∫æN TR·∫†NG TH√ÅI WEBSOCKET ---
let marketWs = null;
let userDataWs = null;
let listenKey = null;
let listenKeyRefreshInterval = null;
let currentMarketPrice = null; // Cache gi√° t·ª´ WebSocket

// --- C·∫§U H√åNH WEB SERVER V√Ä LOG PM2 ---
const WEB_SERVER_PORT = 1230;
const BOT_LOG_FILE = `/home/tacke300/.pm2/logs/${process.env.name || 'home'}-out.log`;
const THIS_BOT_PM2_NAME = process.env.name || 'home';

// --- LOGGING TO FILE ---
const CUSTOM_LOG_FILE = path.join(__dirname, 'pm2.log');
const LOG_TO_CUSTOM_FILE = true;

// --- H√ÄM TI·ªÜN √çCH ---
function addLog(message) {
    const now = new Date();
    const time = `${now.toLocaleDateString('en-GB')} ${now.toLocaleTimeString('en-US', { hour12: false })}.${String(now.getMilliseconds()).padStart(3, '0')}`;
    let logEntry = `[${time}] ${message}`;
    const messageHash = crypto.createHash('md5').update(message).digest('hex');

    if (logCounts[messageHash]) {
        logCounts[messageHash].count++;
        const lastLoggedTime = logCounts[messageHash].lastLoggedTime;

        if ((now.getTime() - lastLoggedTime.getTime()) < LOG_COOLDOWN_MS) {
            return;
        } else {
            if (logCounts[messageHash].count > 1) {
                console.log(`[${time}](L·∫∑p l·∫°i x${logCounts[messageHash].count}) ${message}`);
                if (LOG_TO_CUSTOM_FILE) {
                    fs.appendFile(CUSTOM_LOG_FILE, `[${time}](L·∫∑p l·∫°i x${logCounts[messageHash].count}) ${message}\n`, (err) => {
                        if (err) console.error('L·ªói khi ghi log v√†o file t√πy ch·ªânh:', err);
                    });
                }
            } else {
                console.log(logEntry);
                if (LOG_TO_CUSTOM_FILE) {
                    fs.appendFile(CUSTOM_LOG_FILE, logEntry + '\n', (err) => {
                        if (err) console.error('L·ªói khi ghi log v√†o file t√πy ch·ªânh:', err);
                    });
                }
            }
            logCounts[messageHash] = { count: 1, lastLoggedTime: now };
        }
    } else {
        console.log(logEntry);
        if (LOG_TO_CUSTOM_FILE) {
            fs.appendFile(CUSTOM_LOG_FILE, logEntry + '\n', (err) => {
                if (err) console.error('L·ªói khi ghi log v√†o file t√πy ch·ªânh:', err);
            });
        }
        logCounts[messageHash] = { count: 1, lastLoggedTime: now };
    }
}

function formatTimeUTC7(dateObject) {
    const formatter = new Intl.DateTimeFormat('en-GB', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 3,
        hour12: false,
        timeZone: 'Asia/Ho_Chi_Minh'
    });
    return formatter.format(dateObject);
}

function createSignature(queryString, apiSecret) {
    return crypto.createHmac('sha256', apiSecret)
        .update(queryString)
        .digest('hex');
}

async function makeHttpRequest(method, hostname, path, headers, postData = '') {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: hostname,
            path: path,
            method: method,
            headers: headers,
        };

        const req = https.request(options, (res) => {
            let data = '';
            res.on('data', (chunk) => {
                data += chunk;
            });
            res.on('end', () => {
                if (res.statusCode >= 200 && res.statusCode < 300) {
                    resolve(data);
                } else {
                    const errorMsg = `HTTP Error: ${res.statusCode} ${res.statusMessage}`;
                    let errorDetails = { code: res.statusCode, msg: errorMsg };
                    try {
                        const parsedData = JSON.parse(data);
                        errorDetails = { ...errorDetails, ...parsedData };
                    } catch (e) {
                        errorDetails.msg += ` - Raw: ${data.substring(0, Math.min(data.length, 200))}`;
                    }
                    addLog(`HTTP Request l·ªói: ${errorDetails.msg}`);
                    reject(errorDetails);
                }
            });
        });

        req.on('error', (e) => {
            addLog(`Network l·ªói: ${e.message}`);
            reject({ code: 'NETWORK_ERROR', msg: e.message });
        });

        if (method === 'POST' && postData) {
            req.write(postData);
        }
        req.end();
    });
}

async function callSignedAPI(fullEndpointPath, method = 'GET', params = {}) {
    if (!API_KEY || !SECRET_KEY) {
        throw new CriticalApiError("‚ùå Missing Binance API_KEY ho·∫∑c API_SECRET. Vui l√≤ng ki·ªÉm tra file config.js.");
    }
    const recvWindow = 5000;
    const timestamp = Date.now() + serverTimeOffset;

    let queryString = Object.keys(params)
        .map(key => `${key}=${params[key]}`)
        .join('&');

    queryString += (queryString ? '&' : '') + `timestamp=${timestamp}&recvWindow=${recvWindow}`;

    const signature = createSignature(queryString, SECRET_KEY);

    let requestPath;
    let requestBody = '';
    const headers = {
        'X-MBX-APIKEY': API_KEY,
    };

    if (method === 'GET') {
        requestPath = `${fullEndpointPath}?${queryString}&signature=${signature}`;
        headers['Content-Type'] = 'application/json';
    } else if (method === 'POST') {
        requestPath = fullEndpointPath;
        requestBody = `${queryString}&signature=${signature}`;
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
    } else if (method === 'PUT') {
        requestPath = fullEndpointPath;
        requestBody = `${queryString}&signature=${signature}`;
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
    } else if (method === 'DELETE') {
        requestPath = `${fullEndpointPath}?${queryString}&signature=${signature}`;
        headers['Content-Type'] = 'application/json';
    } else {
        throw new Error(`Method kh√¥ng h·ªó tr·ª£: ${method}`);
    }

    try {
        const rawData = await makeHttpRequest(method, BASE_HOST, requestPath, headers, requestBody);
        consecutiveApiErrors = 0;
        return JSON.parse(rawData);
    } catch (error) {
        consecutiveApiErrors++;
        addLog(`L·ªói k√Ω API Binance: ${error.code || 'UNKNOWN'} - ${error.msg || error.message}`);
        if (error.code === -2015) {
            addLog("  -> Ki·ªÉm tra API Key/Secret v√† quy·ªÅn Futures.");
        } else if (error.code === -1021) {
            addLog("  -> L·ªói l·ªách th·ªùi gian. ƒê·ªìng b·ªô ƒë·ªìng h·ªì m√°y t√≠nh.");
        } else if (error.code === -1003) {
            addLog("  -> B·ªä C·∫§M IP T·∫†M TH·ªúI (RATE LIMIT). C·∫¶N GI·∫¢M T·∫¶N SU·∫§T G·ªåI API!");
        } else if (error.code === -1022) {
            addLog("  -> L·ªói ch·ªØ k√Ω. Ki·ªÉm tra API Key/Secret ho·∫∑c chu·ªói tham s·ªë.");
        } else if (error.code === -4061) {
            addLog("  -> L·ªói -4061 (Order's position side does not match user's setting). ƒê·∫£m b·∫£o ƒë√£ b·∫≠t Hedge Mode v√† l·ªánh c√≥ positionSide ph√π h·ª£p.");
        } else if (error.code === 404) {
            addLog("  -> L·ªói 404. ƒê∆∞·ªùng d·∫´n API sai.");
        } else if (error.code === 'NETWORK_ERROR') {
            addLog("  -> L·ªói m·∫°ng.");
        }

        if (consecutiveApiErrors >= MAX_CONSECUTIVE_API_ERRORS) {
            addLog(`L·ªói API li√™n ti·∫øp (${consecutiveApiErrors}/${MAX_CONSECUTIVE_API_ERRORS}). D·ª´ng bot.`, true);
            throw new CriticalApiError("L·ªói API nghi√™m tr·ªçng, bot d·ª´ng.");
        }
        throw error;
    }
}

async function callPublicAPI(fullEndpointPath, params = {}) {
    const queryString = Object.keys(params)
        .map(key => `${key}=${params[key]}`)
        .join('&');
    const fullPathWithQuery = `${fullEndpointPath}` + (queryString ? `?${queryString}` : '');

    const headers = {
        'Content-Type': 'application/json',
    };

    try {
        const rawData = await makeHttpRequest('GET', BASE_HOST, fullPathWithQuery, headers);
        consecutiveApiErrors = 0;
        return JSON.parse(rawData);
    } catch (error) {
        consecutiveApiErrors++;
        addLog(`L·ªói c√¥ng khai API Binance: ${error.code || 'UNKNOWN'} - ${error.msg || error.message}`);
        if (error.code === -1003) {
            addLog("  -> B·ªä C·∫§M IP T·∫†M TH·ªúI (RATE LIMIT). C·∫¶N GI·∫¢M T·∫¶N SU·∫§T G·ªåI API!");
        } else if (error.code === 404) {
            addLog("  -> L·ªói 404. ƒê∆∞·ªùng d·∫´n API sai.");
        } else if (error.code === 'NETWORK_ERROR') {
            addLog("  -> L·ªói m·∫°ng.");
        }
        if (consecutiveApiErrors >= MAX_CONSECUTIVE_API_ERRORS) {
            addLog(`L·ªói API li√™n ti·∫øp (${consecutiveApiErrors}/${MAX_CONSECUTIVE_API_ERRORS}). D·ª´ng bot.`, true);
            throw new CriticalApiError("L·ªói API nghi√™m tr·ªçng, bot d·ª´ng.");
        }
        throw error;
    }
}

async function syncServerTime() {
    try {
        const data = await callPublicAPI('/fapi/v1/time');
        const binanceServerTime = data.serverTime;
        const localTime = Date.now();
        serverTimeOffset = binanceServerTime - localTime;
        addLog(`ƒê·ªìng b·ªô th·ªùi gian. L·ªách: ${serverTimeOffset} ms.`);
    } catch (error) {
        addLog(`L·ªói ƒë·ªìng b·ªô th·ªùi gian: ${error.message}.`);
        serverTimeOffset = 0;
        throw error;
    }
}

async function getLeverageBracketForSymbol(symbol) {
    try {
        const response = await callSignedAPI('/fapi/v1/leverageBracket', 'GET', { symbol: symbol });
        if (response && Array.isArray(response) && response.length > 0) {
            const symbolData = response.find(item => item.symbol === symbol);
            if (symbolData && symbolData.brackets && Array.isArray(symbolData.brackets) && symbolData.brackets.length > 0) {
                const firstBracket = symbolData.brackets[0];
                return parseInt(firstBracket.maxInitialLeverage || firstBracket.initialLeverage);
            }
        }
        addLog(`Kh√¥ng t√¨m th·∫•y ƒë√≤n b·∫©y h·ª£p l·ªá cho ${symbol}.`);
        return null;
    } catch (error) {
        addLog(`L·ªói l·∫•y ƒë√≤n b·∫©y cho ${symbol}: ${error.msg || error.message}`);
        return null;
    }
}

async function setLeverage(symbol, leverage) {
    try {
        addLog(`ƒê·∫∑t ƒë√≤n b·∫©y ${leverage}x cho ${symbol}.`);
        await callSignedAPI('/fapi/v1/leverage', 'POST', {
            symbol: symbol,
            leverage: leverage
        });
        addLog(`ƒê√£ ƒë·∫∑t ƒë√≤n b·∫©y ${leverage}x cho ${symbol}.`);
        return true;
    } catch (error) {
        addLog(`L·ªói ƒë·∫∑t ƒë√≤n b·∫©y ${leverage}x cho ${symbol}: ${error.msg || error.message}`);
        if (error.code === -4046 || error.code === -4048) {
             addLog(`ƒê√≤n b·∫©y ${leverage}x kh√¥ng h·ª£p l·ªá cho ${symbol}.`);
             return false;
        }
        return false;
    }
}

async function getExchangeInfo() {
    if (exchangeInfoCache) {
        return exchangeInfoCache;
    }

    addLog('L·∫•y exchangeInfo...');
    try {
        const data = await callPublicAPI('/fapi/v1/exchangeInfo');
        addLog(`ƒê√£ nh·∫≠n exchangeInfo. Symbols: ${data.symbols.length}`);

        exchangeInfoCache = {};
        data.symbols.forEach(s => {
            const lotSizeFilter = s.filters.find(f => f.filterType === 'LOT_SIZE');
            const marketLotSizeFilter = s.filters.find(f => f.filterType === 'MARKET_LOT_SIZE');
            const minNotionalFilter = s.filters.find(f => f.filterType === 'MIN_NOTIONAL');
            const priceFilter = s.filters.find(f => f.filterType === 'PRICE_FILTER');

            exchangeInfoCache[s.symbol] = {
                minQty: lotSizeFilter ? parseFloat(lotSizeFilter.minQty) : (marketLotSizeFilter ? parseFloat(marketLotSizeFilter.minQty) : 0),
                stepSize: lotSizeFilter ? parseFloat(lotSizeFilter.stepSize) : (marketLotSizeFilter ? parseFloat(marketLotSizeFilter.minQty) : 0.001),
                minNotional: minNotionalFilter ? parseFloat(minNotionalFilter.notional) : 0,
                pricePrecision: s.pricePrecision,
                quantityPrecision: s.quantityPrecision,
                tickSize: priceFilter ? parseFloat(priceFilter.tickSize) : 0.001
            };
        });
        addLog('ƒê√£ t·∫£i th√¥ng tin s√†n.');
        return exchangeInfoCache;
    } catch (error) {
        addLog('L·ªói l·∫•y exchangeInfo: ' + (error.msg || error.message));
        exchangeInfoCache = null;
        throw error;
    }
}

async function getSymbolDetails(symbol) {
    const filters = await getExchangeInfo();
    if (!filters || !filters[symbol]) {
        addLog(`Kh√¥ng t√¨m th·∫•y filters cho ${symbol}.`);
        return null;
    }
    return filters[symbol];
}

async function getCurrentPrice(symbol) {
    try {
        const data = await callPublicAPI('/fapi/v1/ticker/price', { symbol: symbol });
        const price = parseFloat(data.price);
        return price;
    } catch (error) {
        addLog(`L·ªói l·∫•y gi√° hi·ªán t·∫°i cho ${symbol} t·ª´ REST API: ${error.msg || error.message}`);
        if (error instanceof CriticalApiError) {
             addLog(`L·ªói nghi√™m tr·ªçng khi l·∫•y gi√° cho ${symbol}: ${error.msg || error.message}`);
        }
        return null;
    }
}

async function cancelOpenOrdersForSymbol(symbol, orderId = null, positionSide = null) {
    try {
        let params = { symbol: symbol };
        if (orderId) {
            params.orderId = orderId;
        }
        if (positionSide) {
             params.positionSide = positionSide;
        }

        if (orderId) {
            addLog(`ƒêang h·ªßy l·ªánh ${orderId} cho ${symbol} (positionSide: ${positionSide || 'T·∫•t c·∫£'}).`);
            await callSignedAPI('/fapi/v1/order', 'DELETE', params);
            addLog(`ƒê√£ h·ªßy l·ªánh ${orderId} cho ${symbol}.`);
        } else {
            addLog(`ƒêang h·ªßy t·∫•t c·∫£ l·ªánh ch·ªù cho ${symbol} (positionSide: ${positionSide || 'T·∫•t c·∫£'}).`);
            await callSignedAPI('/fapi/v1/allOpenOrders', 'DELETE', params);
            addLog(`ƒê√£ h·ªßy t·∫•t c·∫£ l·ªánh ch·ªù cho ${symbol}.`);
        }
    } catch (error) {
        addLog(`L·ªói h·ªßy l·ªánh ch·ªù cho ${symbol} (OrderId: ${orderId || 'T·∫§T C·∫¢'}, positionSide: ${positionSide || 'T·∫§T C·∫¢'}): ${error.msg || error.message}`);
        if (error.code === -2011) {
            addLog(`Kh√¥ng c√≥ l·ªánh ch·ªù n√†o ƒë·ªÉ h·ªßy cho ${symbol}.`);
        } else if (error instanceof CriticalApiError) {
             addLog(`Bot d·ª´ng do l·ªói API nghi√™m tr·ªçng khi h·ªßy l·ªánh.`);
             stopBotLogicInternal();
        }
    }
}

async function processTradeResult(orderInfo) {
    const { s: symbol, rp: realizedPnl, S: orderSide, q: orderQuantity, X: orderStatus, i: orderId, ps: positionSide } = orderInfo;

    if (symbol !== TARGET_COIN_SYMBOL) {
        addLog(`B·ªè qua x·ª≠ l√Ω k·∫øt qu·∫£ giao d·ªãch cho ${symbol}. Ch·ªâ x·ª≠ l√Ω cho ${TARGET_COIN_SYMBOL}.`);
        return;
    }

    if (orderStatus !== 'FILLED' || parseFloat(realizedPnl) === 0) {
        return;
    }

    let isFullClosureOrder = false;
    if (currentLongPosition && (orderId === currentLongPosition.currentTPId || orderId === currentLongPosition.currentSLId)) {
        addLog(`L·ªánh LONG kh·ªõp TP/SL ho√†n to√†n.`);
        isFullClosureOrder = true;
    } else if (currentShortPosition && (orderId === currentShortPosition.currentTPId || orderId === currentShortPosition.currentSLId)) {
        addLog(`L·ªánh SHORT kh·ªõp TP/SL ho√†n to√†n.`);
        isFullClosureOrder = true;
    }

    addLog(`ƒêang x·ª≠ l√Ω k·∫øt qu·∫£ giao d·ªãch ${symbol} (PositionSide: ${positionSide}) v·ªõi PNL: ${parseFloat(realizedPnl).toFixed(4)}`);

    if (parseFloat(realizedPnl) > 0.000001) {
        totalProfit += parseFloat(realizedPnl);
    } else if (parseFloat(realizedPnl) < -0.000001) {
        totalLoss += Math.abs(parseFloat(realizedPnl));
    }
    netPNL = totalProfit - totalLoss;

    addLog([
        `üî¥ ƒê√£ ƒë√≥ng ${positionSide} ${symbol}`,
        `‚îú‚îÄ PNL: ${parseFloat(realizedPnl).toFixed(2)} USDT`,
        `‚îú‚îÄ T·ªïng L·ªùi: ${totalProfit.toFixed(2)} USDT`,
        `‚îú‚îÄ T·ªïng L·ªó: ${totalLoss.toFixed(2)} USDT`,
        `‚îî‚îÄ PNL R√≤ng: ${netPNL.toFixed(2)} USDT`
    ].join('\n'));

    if (isFullClosureOrder) {
        addLog(`L·ªánh TP/SL ch√≠nh cho ${symbol} (${positionSide}) ƒë√£ kh·ªõp. ƒêang ƒë√≥ng v·ªã th·∫ø c√≤n l·∫°i.`);
        let closedPosition = null;
        let remainingPosition = null;

        if (positionSide === 'LONG') {
            closedPosition = currentLongPosition;
            remainingPosition = currentShortPosition;
            currentLongPosition = null;
        } else if (positionSide === 'SHORT') {
            closedPosition = currentShortPosition;
            remainingPosition = currentLongPosition;
            currentShortPosition = null;
        }

        if (remainingPosition && Math.abs(remainingPosition.quantity) > 0) {
            addLog(`ƒêang ƒë√≥ng l·ªánh ${remainingPosition.side} (${symbol}) c√≤n l·∫°i.`);
            await closePosition(remainingPosition.symbol, Math.abs(remainingPosition.quantity), `ƒê√≥ng l·ªánh ${positionSide} kh·ªõp TP/SL`, remainingPosition.side);
        } else {
             addLog(`Kh√¥ng t√¨m th·∫•y l·ªánh ƒë·ªëi ·ª©ng c√≤n l·∫°i ƒë·ªÉ ƒë√≥ng ho·∫∑c ƒë√£ ƒë√≥ng r·ªìi.`);
        }

        if (positionCheckInterval) {
            clearInterval(positionCheckInterval);
            positionCheckInterval = null;
        }
        await cancelOpenOrdersForSymbol(symbol, null, 'BOTH');
        await checkAndHandleRemainingPosition(symbol);

        if(botRunning) scheduleNextMainCycle();
    } else {
        addLog(`L·ªánh ${orderId} c√≥ PNL nh∆∞ng kh√¥ng ph·∫£i l·ªánh TP/SL ch√≠nh. Gi·∫£ ƒë·ªãnh l√† ƒë√≥ng t·ª´ng ph·∫ßn. Kh√¥ng reset chu k·ª≥ bot.`);
    }
}

async function closePosition(symbol, quantity, reason, positionSide) {
    if (symbol !== TARGET_COIN_SYMBOL) {
        addLog(`B·ªè qua ƒë√≥ng v·ªã th·∫ø cho ${symbol}. Ch·ªâ ƒë√≥ng cho ${TARGET_COIN_SYMBOL}.`);
        return;
    }

    if (!positionSide || (positionSide !== 'LONG' && positionSide !== 'SHORT')) {
        addLog(`L·ªói: closePosition y√™u c·∫ßu positionSide (LONG/SHORT) r√µ r√†ng trong Hedge Mode. L√Ω do: ${reason}.`);
        return;
    }

    if (isClosingPosition) {
        return;
    }
    isClosingPosition = true;

    addLog(`ƒêang chu·∫©n b·ªã ƒë√≥ng l·ªánh ${positionSide} ${symbol} (L√Ω do: ${reason}).`);

    try {
        const symbolInfo = await getSymbolDetails(symbol);
        if (!symbolInfo) {
            addLog(`L·ªói l·∫•y symbol info ${symbol}. Kh√¥ng ƒë√≥ng l·ªánh.`);
            isClosingPosition = false;
            return;
        }

        const quantityPrecision = symbolInfo.quantityPrecision;
        const positions = await callSignedAPI('/fapi/v2/positionRisk', 'GET');
        const currentPositionOnBinance = positions.find(p => p.symbol === symbol && p.positionSide === positionSide && parseFloat(p.positionAmt) !== 0);

        if (!currentPositionOnBinance || parseFloat(currentPositionOnBinance.positionAmt) === 0) {
            addLog(`${symbol} (PositionSide: ${positionSide}) ƒë√£ ƒë√≥ng tr√™n s√†n ho·∫∑c kh√¥ng c√≥ v·ªã th·∫ø ƒë·ªÉ ƒë√≥ng. L√Ω do: ${reason}.`);
        } else {
            const actualQuantityToClose = Math.abs(parseFloat(currentPositionOnBinance.positionAmt));
            const adjustedActualQuantity = parseFloat(actualQuantityToClose.toFixed(quantityPrecision));
            const closeSide = (positionSide === 'LONG') ? 'SELL' : 'BUY';

            if (adjustedActualQuantity <= 0) {
                addLog(`S·ªë l∆∞·ª£ng ƒë√≥ng (${adjustedActualQuantity}) cho ${symbol} (PositionSide: ${positionSide}) kh√¥ng h·ª£p l·ªá. Kh√¥ng g·ª≠i l·ªánh ƒë√≥ng.`);
                isClosingPosition = false;
                return;
            }

            addLog(`G·ª≠i l·ªánh ƒë√≥ng: ${symbol}, Side: ${closeSide}, PositionSide: ${positionSide}, Type: MARKET, Qty: ${adjustedActualQuantity}`);

            await callSignedAPI('/fapi/v1/order', 'POST', {
                symbol: symbol,
                side: closeSide,
                positionSide: positionSide,
                type: 'MARKET',
                quantity: adjustedActualQuantity,
            });

            addLog(`ƒê√£ g·ª≠i l·ªánh ƒë√≥ng ${closeSide} ${symbol} (PositionSide: ${positionSide}). L√Ω do: ${reason}.`);
            await sleep(1000);
        }

    } catch (error) {
        addLog(`L·ªói ƒë√≥ng v·ªã th·∫ø ${symbol} (PositionSide: ${positionSide}): ${error.msg || error.message}`);
        if (error.code === -2011) {
            addLog(`L·ªói -2011 khi ƒë√≥ng v·ªã th·∫ø ${symbol} (PositionSide: ${positionSide}), c√≥ th·ªÉ v·ªã th·∫ø ƒë√£ ƒë√≥ng. Ki·ªÉm tra l·∫°i.`);
            await checkAndHandleRemainingPosition(symbol);
        }
        else if (error instanceof CriticalApiError) {
            addLog(`Bot d·ª´ng do l·ªói API nghi√™m tr·ªçng khi c·ªë g·∫Øng ƒë√≥ng v·ªã th·∫ø.`);
            stopBotLogicInternal();
        }
    } finally {
        isClosingPosition = false;
    }
}

async function closePartialPosition(position, percentageOfInitialQuantity, type = 'PROFIT') {
    if (position.initialQuantity === undefined || position.initialQuantity <= 0) {
        addLog(`L·ªói: Kh√¥ng c√≥ kh·ªëi l∆∞·ª£ng ban ƒë·∫ßu h·ª£p l·ªá (initialQuantity) cho l·ªánh ${position.side} ${position.symbol}. Kh√¥ng th·ªÉ ƒë√≥ng t·ª´ng ph·∫ßn.`);
        return;
    }

    addLog(`ƒêang ƒë√≥ng ${percentageOfInitialQuantity}% kh·ªëi l∆∞·ª£ng ban ƒë·∫ßu c·ªßa l·ªánh ${position.side} ${position.symbol} (type: ${type === 'PROFIT' ? 'l√£i' : 'l·ªó'}).`);

    try {
        const symbolInfo = await getSymbolDetails(position.symbol);
        if (!symbolInfo) {
            addLog(`L·ªói l·∫•y symbol info ${position.symbol}. Kh√¥ng ƒë√≥ng t·ª´ng ph·∫ßn.`);
            return;
        }

        const quantityPrecision = symbolInfo.quantityPrecision;

        let quantityToClose = position.initialQuantity * (percentageOfInitialQuantity / 100);

        const positionsOnBinance = await callSignedAPI('/fapi/v2/positionRisk', 'GET');
        const currentPositionOnBinance = positionsOnBinance.find(p => p.symbol === position.symbol && p.positionSide === position.side && Math.abs(parseFloat(p.positionAmt)) > 0);

        if (!currentPositionOnBinance || Math.abs(parseFloat(currentPositionOnBinance.positionAmt)) === 0) {
            addLog(`V·ªã th·∫ø ${position.side} ${position.symbol} ƒë√£ ƒë√≥ng tr√™n s√†n ho·∫∑c kh√¥ng t·ªìn t·∫°i. Kh√¥ng th·ªÉ ƒë√≥ng t·ª´ng ph·∫ßn.`);
            return;
        }

        const actualPositionQuantity = Math.abs(parseFloat(currentPositionOnBinance.positionAmt));

        const roundToStepSize = (qty, step) => {
            return Math.floor(qty / step) * step;
        };

        quantityToClose = roundToStepSize(quantityToClose, symbolInfo.stepSize);
        quantityToClose = parseFloat(quantityToClose.toFixed(quantityPrecision));

        const MIN_PARTIAL_CLOSE_VALUE_USDT = 0.003;

        if (quantityToClose <= 0) {
            addLog(`S·ªë l∆∞·ª£ng ƒë√≥ng t·ª´ng ph·∫ßn (${quantityToClose.toFixed(quantityPrecision)}) qu√° nh·ªè ho·∫∑c b·∫±ng 0 cho ${position.symbol}.`);
            return;
        }

        const currentPrice = position.currentPrice; 
        if (!currentPrice || currentPrice <= 0) {
             addLog(`Kh√¥ng c√≥ gi√° hi·ªán t·∫°i h·ª£p l·ªá cho ${position.symbol}. Kh√¥ng th·ªÉ ƒë√≥ng t·ª´ng ph·∫ßn.`);
             return;
        }

        if (quantityToClose * currentPrice < MIN_PARTIAL_CLOSE_VALUE_USDT) {
            addLog(`Gi√° tr·ªã l·ªánh ƒë√≥ng t·ª´ng ph·∫ßn nh·ªè h∆°n ${MIN_PARTIAL_CLOSE_VALUE_USDT} USDT. Kh√¥ng ƒë√≥ng ƒë·ªÉ tr√°nh l·ªói l√†m tr√≤n/notional.`);
            return;
        }

        if (quantityToClose > actualPositionQuantity) {
            addLog(`C·∫£nh b√°o: S·ªë l∆∞·ª£ng t√≠nh to√°n ƒë·ªÉ ƒë√≥ng t·ª´ng ph·∫ßn (${quantityToClose.toFixed(quantityPrecision)}) l·ªõn h∆°n s·ªë l∆∞·ª£ng v·ªã th·∫ø hi·ªán t·∫°i (${actualPositionQuantity.toFixed(quantityPrecision)}). ƒêi·ªÅu ch·ªânh ƒë·ªÉ ƒë√≥ng t·ªëi ƒëa s·ªë l∆∞·ª£ng c√≤n l·∫°i.`);
            quantityToClose = actualPositionQuantity;
            quantityToClose = roundToStepSize(quantityToClose, symbolInfo.stepSize);
            quantityToClose = parseFloat(quantityToClose.toFixed(quantityPrecision));
        }

        if (quantityToClose <= 0) {
            addLog(`Sau khi ki·ªÉm tra, s·ªë l∆∞·ª£ng ƒë√≥ng t·ª´ng ph·∫ßn v·∫´n l√† 0 ho·∫∑c kh√¥ng h·ª£p l·ªá. H·ªßy ƒë√≥ng.`);
            return;
        }

        const closeSide = position.side === 'LONG' ? 'SELL' : 'BUY';

        addLog(`G·ª≠i l·ªánh ƒë√≥ng t·ª´ng ph·∫ßn: ${position.symbol}, Side: ${closeSide}, PositionSide: ${position.side}, Type: MARKET, Qty: ${quantityToClose}`);
        const orderResult = await callSignedAPI('/fapi/v1/order', 'POST', {
            symbol: position.symbol,
            side: closeSide,
            positionSide: position.side,
            type: 'MARKET',
            quantity: quantityToClose,
        });

        addLog(`ƒê√£ g·ª≠i l·ªánh ƒë√≥ng t·ª´ng ph·∫ßn ${closeSide} ${position.symbol}. OrderId: ${orderResult.orderId}`);

        const usdtAmountClosed = quantityToClose * currentPrice;

        if (type === 'PROFIT') {
            position.closedAmount += usdtAmountClosed; 
        } else { 
            position.closedLossAmount += usdtAmountClosed; 
        }

        addLog(`ƒê√£ g·ª≠i l·ªánh ƒë√≥ng ${percentageOfInitialQuantity}% kh·ªëi l∆∞·ª£ng ban ƒë·∫ßu c·ªßa l·ªánh ${position.side}.`);
        addLog(`T·ªïng v·ªën (USDT) ƒë√£ ƒë√≥ng t·ª´ l√£i: ${position.closedAmount.toFixed(2)} USDT.`);
        addLog(`T·ªïng v·ªën (USDT) ƒë√£ ƒë√≥ng t·ª´ l·ªó: ${position.closedLossAmount.toFixed(2)} USDT.`);

        await sleep(1000); 

    } catch (error) {
        addLog(`L·ªói khi ƒë√≥ng t·ª´ng ph·∫ßn l·ªánh ${position.side} ${position.symbol}: ${error.msg || error.message}`);
        if (error.code === -2011) {
            addLog(`L·ªói -2011 khi ƒë√≥ng t·ª´ng ph·∫ßn ${position.side} ${position.symbol}, c√≥ th·ªÉ v·ªã th·∫ø ƒë√£ ƒë√≥ng ho√†n to√†n.`);
        }
        else if (error instanceof CriticalApiError) {
            addLog(`Bot d·ª´ng do l·ªói API nghi√™m tr·ªçng khi ƒë√≥ng t·ª´ng ph·∫ßn.`);
            stopBotLogicInternal();
        }
    }
}

async function addPosition(position, amountToReopen, type = 'PROFIT') {
    if (amountToReopen <= 0) {
        addLog(`Kh√¥ng c√≥ s·ªë v·ªën ƒë·ªÉ m·ªü th√™m cho l·ªánh ${position.side} ${position.symbol}.`);
        return;
    }

    addLog(`ƒêang m·ªü th√™m ${amountToReopen.toFixed(2)} USDT cho l·ªánh ${position.side} ${position.symbol} (type: ${type === 'PROFIT' ? 'b√π l√£i ƒë√£ ch·ªët' : 'b√π l·ªó ƒë√£ c·∫Øt'}).`);

    try {
        const symbolDetails = await getSymbolDetails(position.symbol);
        if (!symbolDetails) {
            addLog(`L·ªói l·∫•y chi ti·∫øt symbol ${position.symbol}. Kh√¥ng m·ªü th√™m l·ªánh.`);
            return;
        }

        const { pricePrecision, quantityPrecision, minNotional, stepSize, tickSize } = symbolDetails;
        const currentPrice = await getCurrentPrice(position.symbol);
        if (!currentPrice) {
            addLog(`Kh√¥ng c√≥ gi√° hi·ªán t·∫°i h·ª£p l·ªá cho ${position.symbol}. Kh√¥ng th·ªÉ m·ªü th√™m.`);
            return;
        }

        const maxLeverage = position.maxLeverageUsed;
        if (!maxLeverage) {
            addLog(`Kh√¥ng th·ªÉ l·∫•y ƒë√≤n b·∫©y ƒë√£ s·ª≠ d·ª•ng cho ${position.symbol}.`);
            return;
        }

        let quantityToAdd = (amountToReopen * maxLeverage) / currentPrice;
        quantityToAdd = Math.floor(quantityToAdd / stepSize) * stepSize;
        quantityToAdd = parseFloat(quantityToAdd.toFixed(quantityPrecision));

        if (quantityToAdd <= 0 || quantityToAdd * currentPrice < minNotional) {
            addLog(`S·ªë l∆∞·ª£ng ho·∫∑c gi√° tr·ªã l·ªánh m·ªü th√™m qu√° nh·ªè (${quantityToAdd.toFixed(quantityPrecision)} Qty, Notional: ${quantityToAdd * currentPrice}). H·ªßy.`);
            return;
        }

        const orderSide = position.side === 'LONG' ? 'BUY' : 'SELL';

        const orderResult = await callSignedAPI('/fapi/v1/order', 'POST', {
            symbol: position.symbol,
            side: orderSide,
            positionSide: position.side,
            type: 'MARKET',
            quantity: quantityToAdd,
            newOrderRespType: 'FULL'
        });

        addLog(`ƒê√£ g·ª≠i l·ªánh MARKET ƒë·ªÉ m·ªü th√™m ${orderSide} ${position.symbol}. OrderId: ${orderResult.orderId}`);
        await sleep(1000);

        const positionsOnBinance = await callSignedAPI('/fapi/v2/positionRisk', 'GET');
        const updatedPositionOnBinance = positionsOnBinance.find(p => p.symbol === position.symbol && p.positionSide === position.side && Math.abs(parseFloat(p.positionAmt)) > 0);

        if (updatedPositionOnBinance) {
            const oldTotalCost = position.entryPrice * position.quantity;
            const newTotalCost = parseFloat(updatedPositionOnBinance.entryPrice) * Math.abs(parseFloat(updatedPositionOnBinance.positionAmt));
            const newTotalQuantity = Math.abs(parseFloat(updatedPositionOnBinance.positionAmt));
            const newEntryPrice = newTotalCost / newTotalQuantity;

            position.entryPrice = newEntryPrice;
            position.quantity = newTotalQuantity;

            addLog(`ƒê√£ m·ªü th√™m th√†nh c√¥ng cho ${position.side} ${position.symbol}. S·ªë l∆∞·ª£ng m·ªõi: ${position.quantity.toFixed(quantityPrecision)}, Gi√° v√†o trung b√¨nh m·ªõi: ${newEntryPrice.toFixed(pricePrecision)}.`);

            if (type === 'PROFIT') {
                position.closedAmount = 0;
                position.nextPartialCloseIndex = 0; 
            } else { 
                position.closedLossAmount = 0;
                position.nextPartialCloseLossIndex = 0; 
            }
            
            position.hasAdjustedSLTo200PercentProfit = false; 
            position.hasAdjustedSLTo500PercentProfit = false; 

            await updateTPandSLForTotalPosition(position, maxLeverage);

        } else {
            addLog(`Kh√¥ng t√¨m th·∫•y v·ªã th·∫ø ${position.side} ${position.symbol} sau khi m·ªü th√™m. L·ªói ƒë·ªìng b·ªô.`);
        }

    } catch (error) {
        addLog(`L·ªói khi m·ªü th√™m l·ªánh cho ${position.side} ${position.symbol}: ${error.msg || error.message}`);
        if (error instanceof CriticalApiError) {
            addLog(`Bot d·ª´ng do l·ªói API nghi√™m tr·ªçng khi m·ªü th√™m l·ªánh.`);
            stopBotLogicInternal();
        }
    }
}

// --- KH·ªûI T·∫†O WEB SERVER V√Ä C√ÅC API ENDPOINT ---
const app = express();
app.use(express.json());

app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

app.get('/api/logs', (req, res) => {
    fs.readFile(CUSTOM_LOG_FILE, 'utf8', (err, customLogData) => {
        if (!err && customLogData && customLogData.trim().length > 0) {
            const cleanData = customLogData.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
            const lines = cleanData.split('\n');
            const maxDisplayLines = 500;
            const startIndex = Math.max(0, lines.length - maxDisplayLines);
            const limitedLogs = lines.slice(startIndex).join('\n');
            res.send(limitedLogs);
        } else {
            fs.readFile(BOT_LOG_FILE, 'utf8', (err, pm2LogData) => {
                if (err) {
                    console.error('L·ªói ƒë·ªçc log file:', err);
                    if (err.code === 'ENOENT') {
                        return res.status(404).send(`Kh√¥ng t√¨m th·∫•y log file: ${BOT_LOG_FILE}. ƒê·∫£m b·∫£o PM2 ƒëang ch·∫°y v√† t√™n log ch√≠nh x√°c.`);
                    }
                    return res.status(500).send('L·ªói ƒë·ªçc log file');
                }
                const cleanData = pm2LogData.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
                const lines = cleanData.split('\n');
                const maxDisplayLines = 500;
                const startIndex = Math.max(0, lines.length - maxDisplayLines);
                const limitedLogs = lines.slice(startIndex).join('\n');
                res.send(limitedLogs);
            });
        }
    });
});

app.get('/api/status', async (req, res) => {
    try {
        const pm2List = await new Promise((resolve, reject) => {
            exec('pm2 jlist', (error, stdout, stderr) => {
                if (error) reject(stderr || error.message);
                resolve(stdout);
            });
        });
        const processes = JSON.parse(pm2List);
        const botProcess = processes.find(p => p.name === THIS_BOT_PM2_NAME);

        let statusMessage = 'MAY CHU: DA TAT (PM2)';
        if (botProcess) {
            statusMessage = `MAY CHU: ${botProcess.pm2_env.status.toUpperCase()} (Restarts: ${botProcess.pm2_env.restart_time})`;
            if (botProcess.pm2_env.status === 'online') {
                statusMessage += ` | TRANG THAI BOT: ${botRunning ? 'DANG CHAY' : 'DA DUNG'}`;
                if (botStartTime) {
                    const uptimeMs = Date.now() - botStartTime.getTime();
                    const uptimeMinutes = Math.floor(uptimeMs / (1000 * 60));
                    statusMessage += ` | DA CHAY: ${uptimeMinutes} ph√∫t`;
                }
                statusMessage += ` | Coin: ${TARGET_COIN_SYMBOL}`;
                statusMessage += ` | V·ªën l·ªánh: ${INITIAL_INVESTMENT_AMOUNT} USDT`;
            }
        } else {
            statusMessage = `Bot: Kh√¥ng t√¨m th·∫•y trong PM2 (T√™n: ${THIS_BOT_PM2_NAME}). ƒê·∫£m b·∫£o ƒë√£ ch·∫°y PM2!`;
        }
        res.send(statusMessage);
    } catch (error) {
        console.error('L·ªói l·∫•y tr·∫°ng th√°i PM2:', error);
        res.status(500).send(`Bot: L·ªói l·∫•y tr·∫°ng th√°i. (${error})`);
    }
});

app.get('/api/bot_stats', async (req, res) => {
    try {
        let openPositionsData = [];
        if (currentLongPosition && currentLongPosition.symbol === TARGET_COIN_SYMBOL) {
            openPositionsData.push({
                symbol: currentLongPosition.symbol,
                side: currentLongPosition.side,
                quantity: currentLongPosition.quantity,
                initialQuantity: currentLongPosition.initialQuantity,
                entryPrice: currentLongPosition.entryPrice,
                currentPrice: currentLongPosition.currentPrice || 0,
                unrealizedPnl: currentLongPosition.unrealizedPnl || 0,
                pricePrecision: currentLongPosition.pricePrecision,
                TPId: currentLongPosition.currentTPId,
                SLId: currentLongPosition.currentSLId,
                initialMargin: currentLongPosition.initialMargin,
                closedAmount: currentLongPosition.closedAmount,
                partialCloseLevels: currentLongPosition.partialCloseLevels,
                nextPartialCloseIndex: currentLongPosition.nextPartialCloseIndex,
                closedLossAmount: currentLongPosition.closedLossAmount,
                partialCloseLossLevels: currentLongPosition.partialCloseLossLevels,
                nextPartialCloseLossIndex: currentLongPosition.nextPartialCloseLossIndex,
                hasAdjustedSLTo200PercentProfit: currentLongPosition.hasAdjustedSLTo200PercentProfit,
                hasAdjustedSLTo500PercentProfit: currentLongPosition.hasAdjustedSLTo500PercentProfit,
            });
        }
        if (currentShortPosition && currentShortPosition.symbol === TARGET_COIN_SYMBOL) {
            openPositionsData.push({
                symbol: currentShortPosition.symbol,
                side: currentShortPosition.side,
                quantity: currentShortPosition.quantity,
                initialQuantity: currentShortPosition.initialQuantity,
                entryPrice: currentShortPosition.entryPrice,
                currentPrice: currentShortPosition.currentPrice || 0,
                unrealizedPnl: currentShortPosition.unrealizedPnl || 0,
                pricePrecision: currentShortPosition.pricePrecision,
                TPId: currentShortPosition.currentTPId,
                SLId: currentShortPosition.currentSLId,
                initialMargin: currentShortPosition.initialMargin,
                closedAmount: currentShortPosition.closedAmount,
                partialCloseLevels: currentShortPosition.partialCloseLevels,
                nextPartialCloseIndex: currentShortPosition.nextPartialCloseIndex,
                closedLossAmount: currentShortPosition.closedLossAmount,
                partialCloseLossLevels: currentShortPosition.partialCloseLossLevels,
                nextPartialCloseLossIndex: currentShortPosition.nextPartialCloseLossIndex,
                hasAdjustedSLTo200PercentProfit: currentShortPosition.hasAdjustedSLTo200PercentProfit,
                hasAdjustedSLTo500PercentProfit: currentShortPosition.hasAdjustedSLTo500PercentProfit,
            });
        }

        res.json({
            success: true,
            data: {
                totalProfit: totalProfit,
                totalLoss: totalLoss,
                netPNL: netPNL,
                currentOpenPositions: openPositionsData,
                currentInvestmentAmount: INITIAL_INVESTMENT_AMOUNT,
            }
        });
    } catch (error) {
        console.error('L·ªói khi l·∫•y th·ªëng k√™ bot:', error);
        res.status(500).json({ success: false, message: 'L·ªói khi l·∫•y th·ªëng k√™ bot.' });
    }
});

app.post('/api/configure', (req, res) => {
    const { coinConfigs } = req.body;

    if (coinConfigs && coinConfigs.length > 0) {
        const config = coinConfigs[0];
        const oldTargetCoinSymbol = TARGET_COIN_SYMBOL;
        TARGET_COIN_SYMBOL = config.symbol.trim().toUpperCase();
        INITIAL_INVESTMENT_AMOUNT = parseFloat(config.initialAmount);

        if (oldTargetCoinSymbol !== TARGET_COIN_SYMBOL) {
            addLog(`ƒê·ªìng coin m·ª•c ti√™u ƒë√£ thay ƒë·ªïi t·ª´ ${oldTargetCoinSymbol} sang ${TARGET_COIN_SYMBOL}. Reset tr·∫°ng th√°i giao d·ªãch.`);
            currentLongPosition = null;
            currentShortPosition = null;
            totalProfit = 0;
            totalLoss = 0;
            netPNL = 0;
            if (positionCheckInterval) {
                clearInterval(positionCheckInterval);
                positionCheckInterval = null;
            }
            if (botRunning) {
                setupMarketDataStream(TARGET_COIN_SYMBOL);
            }
        }
    } else {
        addLog("C·∫£nh b√°o: Kh√¥ng c√≥ c·∫•u h√¨nh ƒë·ªìng coin n√†o ƒë∆∞·ª£c g·ª≠i.");
    }

    addLog(`ƒê√£ c·∫≠p nh·∫≠t c·∫•u h√¨nh:`);
    addLog(`  API Key: ƒê√£ thi·∫øt l·∫≠p t·ª´ file config.js`);
    addLog(`  Secret Key: ƒê√£ thi·∫øt l·∫≠p t·ª´ file config.js`);
    addLog(`  ƒê·ªìng coin: ${TARGET_COIN_SYMBOL}`);
    addLog(`  S·ªë v·ªën ban ƒë·∫ßu (m·ªói l·ªánh): ${INITIAL_INVESTMENT_AMOUNT} USDT`);

    res.json({ success: true, message: 'C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.' });
});

app.get('/start_bot_logic', async (req, res) => {
    const message = await startBotLogicInternal();
    res.send(message);
});

app.get('/stop_bot_logic', (req, res) => {
    const message = stopBotLogicInternal();
    res.send(message);
});

app.listen(WEB_SERVER_PORT, () => {
    addLog(`Web server tr√™n c·ªïng ${WEB_SERVER_PORT}`);
    addLog(`Truy c·∫≠p: http://localhost:${WEB_SERVER_PORT}`);
});
